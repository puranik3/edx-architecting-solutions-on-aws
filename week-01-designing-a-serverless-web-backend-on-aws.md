# Week 1 - Designing a serverless web backend on AWS

## Customer #1: Use Case and Requirements
- Have used lift-and-shift to migrate to AWS so fay
- looking to use cloud-native (AWS-native) technologies now
- e-commerce store with website and app
    - customer shops
    - customer can also purchase wholesale, for selling in their retail stores
    - __orders service__ accepts orders from web and mobile and is __hosted on-premise__
        - authenticates, validates and accepts (or rejects) orders, processes them, and stores them in the DB
        - calls downstream services like
            - inventory service
            - fulfilment service
            - accounting service
            - __these downstream services are already on AWS!__
        - __Assumption__: Payment has already been processed using a payment gateway, before the order service is invoked
    - web server accepting order requests and application server are right now the same
    - __uses a MySQL DB on-premise__
    - downstream services work with their own DB
    - open to migrating DB
    - DB required to be highly available and durable
    - order details are right now maintained in only 1 table! - data is minimal and maintaining a whole DB seems overkill
    - what are the current pain points that are driving rewrite/re-architecting rather than lift-and-shift?
        - when there are large number of orders, service is unable to handle it, and orders get dropped
            - i.e. scaling quickly on-demand on-premise is a problem currently
            - looking for automatic scaling
        - sometimes some downstream service calls are completed but others are not as order service crashes before order completion
            - eg. call to inventory service completed
            - before its result could be processed by the order service (and calls made to fulfilment and accounting), the order service crashes
                - __problem is the services are tightly coupled__
            - need is to decouple the services to increase resilience of the app
        - result in loss of orders, inconsistency in orders data for customers
    - app encounters spiky demand from customers (as opposed to low/high volume steady/cyclical demand)
        - demand increases when coupons are sent out, or as part of sales campaigns
        - otherwise close to no demand
        - right now on-premise data center needs to over-provision resources
    - company is open to rewrite code to go cloud-native
    - need monitoring and logging, and common logging system throughout the app
    - need to optimize the solution for cost and performance
        
## Customer #1: Requirements Breakdown
- migrating from on-premises to SOA on AWS
- orders service is built as a monolith
- web server, orders service, DB are in scope of migration
    - 3 downstream services are out-of-scope
- service needs to be more resilient
    - failure of one part of the app does not affect other parts
    - suggests loose-coupling through event-driven architecture
- manage scaling for DB and compute
    - suggests serverless architecture as its fully-managed!
- centralized monitoring and logging
    - serverless services are already well-integrated with CloudWatch and CloudWatch Logs
- optimizing for cost, performance efficiency, operational overhead
    - __cost shall be the main driver for choice of services__
    - __performance efficiency, operational overhead are secondary drivers for the choices__
    - again serverless optimizes these factors in this priority!
    - also, once we architect we can review various choices of servies and see how to optimize further for these 3 factors


## Selecting a Serverless Compute Service
- Some options for compute service
    - Check the table of various services and their use cases on this page - https://aws.amazon.com/products/compute/
    - EC2
    - Lightsail
    - ECS
    - EKS
    - Fargate
    - Lambda
- EC2 could be used for lift-and-shift requirement. But it involves some management on customer's parts - in this case customer does not want to manage servers
- Container orchestration services like ECS, EKS can run containers on EC2 (unmanaged) or Fargate (managed)
    - Fargate is a good choice for this requirement as
        - it is managed
        - logs and metrics go to CloudWatch
        - no idle instances (managed scaling)
    - But we are _not sure if customer is interested in using containers_!
- __Lambda is _cloud-native___ - i.e. designed to take advantage of all the services the AWS cloud has to offer!
    - serverless (managed)
    - logs and metrics go to CloudWatch
    - some configurations still need to be maintained and tweaked over time
    - some things you may still need to do to make scaling happen faster, code run faster
    - but these operational overheads are still minimal compared to EC2
    - When an event triggers a function, Lambda 
        - runs the task on a micro-VM called Firecracker
        - shuts down the VM if it idling for a period of time
- So, which one to use?
    - ask the customer!
    - __customer says there aren't people skilled enough to use containers__!
- So...Lambda is the winner
    - orders service needs to be rewritten to a set of functions that can be invoked by Lambda
        - but that is not much difference or much work!
    - also __triggers for functions need to be configured__
        - a trigger for Lambda can be
            - SQS message being enqueued
            - HTTP/HTTPS request from API Gateway
            - request via ELB
            - etc.
- We can choose __Amazon API Gateway for the web server__ and can
    - forward incoming HTTP/HTTPS requests for orders service endpoints
    - handle authentiction requests
    - handle request validation
    - managed scalable
    - like Lambda logs and metrics go to CloudWatch!

## Resources
- [AWS compute services](https://aws.amazon.com/products/compute/)