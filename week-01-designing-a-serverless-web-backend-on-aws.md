# Week 1 - Designing a serverless web backend on AWS

## Customer #1: Use Case and Requirements
- Have used lift-and-shift to migrate to AWS so fay
- looking to use cloud-native (AWS-native) technologies now
- e-commerce store with website and app
    - customer shops
    - customer can also purchase wholesale, for selling in their retail stores
    - __orders service__ accepts orders from web and mobile and is __hosted on-premise__
        - authenticates, validates and accepts (or rejects) orders, processes them, and stores them in the DB
        - calls downstream services like
            - inventory service
            - fulfilment service
            - accounting service
            - __these downstream services are already on AWS!__
        - __Assumption__: Payment has already been processed using a payment gateway, before the order service is invoked
    - web server accepting order requests and application server are right now the same
    - __uses a MySQL DB on-premise__
    - downstream services work with their own DB
    - open to migrating DB
    - DB required to be highly available and durable
    - order details are right now maintained in only 1 table! - data is minimal and maintaining a whole DB seems overkill
    - what are the current pain points that are driving rewrite/re-architecting rather than lift-and-shift?
        - when there are large number of orders, service is unable to handle it, and orders get dropped
            - i.e. scaling quickly on-demand on-premise is a problem currently
            - looking for automatic scaling
        - sometimes some downstream service calls are completed but others are not as order service crashes before order completion
            - eg. call to inventory service completed
            - before its result could be processed by the order service (and calls made to fulfilment and accounting), the order service crashes
                - __problem is the services are tightly coupled__
            - need is to decouple the services to increase resilience of the app
        - result in loss of orders, inconsistency in orders data for customers
    - app encounters spiky demand from customers (as opposed to low/high volume steady/cyclical demand)
        - demand increases when coupons are sent out, or as part of sales campaigns
        - otherwise close to no demand
        - right now on-premise data center needs to over-provision resources
    - company is open to rewrite code to go cloud-native
    - need monitoring and logging, and common logging system throughout the app
    - need to optimize the solution for cost and performance
        
## Customer #1: Requirements Breakdown
- migrating from on-premises to SOA on AWS
- orders service is built as a monolith
- web server, orders service, DB are in scope of migration
    - 3 downstream services are out-of-scope
- service needs to be more resilient
    - failure of one part of the app does not affect other parts
    - suggests loose-coupling through event-driven architecture
- manage scaling for DB and compute
    - suggests serverless architecture as its fully-managed!
- centralized monitoring and logging
    - serverless services are already well-integrated with CloudWatch and CloudWatch Logs
- optimizing for cost, performance efficiency, operational overhead
    - __cost shall be the main driver for choice of services__
    - __performance efficiency, operational overhead are secondary drivers for the choices__
    - again serverless optimizes these factors in this priority!
    - also, once we architect we can review various choices of servies and see how to optimize further for these 3 factors


## Selecting a Serverless Compute Service
- Some options for compute service
    - Check the table of various services and their use cases on this page - https://aws.amazon.com/products/compute/
    - EC2
    - Lightsail
    - ECS
    - EKS
    - Fargate
    - Lambda
- EC2 could be used for lift-and-shift requirement. But it involves some management on customer's parts - in this case customer does not want to manage servers
- Container orchestration services like ECS, EKS can run containers on EC2 (unmanaged) or Fargate (managed)
    - Fargate is a good choice for this requirement as
        - it is managed
        - logs and metrics go to CloudWatch
        - no idle instances (managed scaling)
    - But we are _not sure if customer is interested in using containers_!
- __Lambda is _cloud-native___ - i.e. designed to take advantage of all the services the AWS cloud has to offer!
    - serverless (managed)
    - logs and metrics go to CloudWatch
    - some configurations still need to be maintained and tweaked over time
    - some things you may still need to do to make scaling happen faster, code run faster
    - but these operational overheads are still minimal compared to EC2
    - When an event triggers a function, Lambda 
        - runs the task on a micro-VM called Firecracker (called the `execution environment`)
        - shuts down the VM if it idling for a period of time
- So, which one to use?
    - ask the customer!
    - __customer says there aren't people skilled enough to use containers__!
- So...Lambda is the winner
    - orders service needs to be rewritten to a set of functions that can be invoked by Lambda
        - but that is not much difference or much work!
    - also __triggers for functions need to be configured__
        - a trigger for Lambda can be
            - SQS message being enqueued
            - HTTP/HTTPS request from API Gateway
            - request via ELB
            - etc.
- We can choose __Amazon API Gateway for the web server__ and can
    - forward incoming HTTP/HTTPS requests for orders service endpoints
    - handle authentiction requests
    - handle request validation
    - managed scalable
    - like Lambda logs and metrics go to CloudWatch!

## AWS Lambda Exploration
- Create a function
    - name it
    - choose runtime (like java 8, .NET 6, Node 16 etc.)
        - you can even choose a custom runtime if the off-the-shelf supported does not have what you need
    - create an IAM role that the Lambda can assume when it executes the function
        - this defines what services are available to the Lambda (or rather the function running on it)
    - enable VPC if you want to communicate with a resource in a private VPC (eg. an RDS DB)
    - add trigger
        - triggers can be AWS services
        - using Amazon aws/eventbridge, you can even trigger from many popular third-party SaaS services like Auth0, Datadog, Freshworks, MongoDB etc.
        - eg. set up an API Gateway with an API to invoke the function - this creates an HTTP/REST endpoint (as you choose)
    - code signing
        - only approved developers publish unaltered, trusted code in your functions
    - the function can be uploaded, defined in the code editor (`Code` tab)
        - gets `event`, `context` as arguments
            - event has details of payload of the request
            - context of the execution
        - code is stored in S3 with encryption at rest
            - integrity checks are performed when code is used
        - code should be __stateless__
            - should assume no affinity to the underlying compute infrastructure
            - local file system access, child processes cannot extend beyond the lifetime of the request
                - 512MB of instance's own ephemeral storage is free of cost
                - you can configure between 512MB - 10,240MB, in 1MB increments (`/tmp` directory) at a price
                - CloudWatch can be used to monitor ephemeral storage usage!
            - persistent state should be stored in S3, DynamoDB, RDS, EFS, or another internet-available storage service
        - manage versions
            - eg. a new version of a function can be used for beta testing without affecting users of the stable production version
    - logs can be
        - runtime logs (eg. details of invocation)
        - application logs (that the function logs)
    - the `Test` tab can be used to make an HTTP request for testing the execution
    - add destination

## Reading 1.2: Compute on AWS
- before selecting any service, ensure that you are up to date on any new AWS service or feature releases
- [High-level overview of the different AWS compute services for any worload](https://aws.amazon.com/products/compute/)

### AWS Lambda
- Lambda functions can run for up to 15 minutes
    - __any processes that needs > 15 minutes should use other compute services on AWS__!
- metered in 1ms increments
- each execution environment stays active for a period of time, and then it shuts down on its own
- managed nature makes it easier to optimize for operational efficiency and have low operational overhead
    - Lambda manages the compute fleet, which offers a balance of memory, CPU, network, and other resources to run your code
    - you can't log in to compute instances, customize OS etc.
    - Lambda manages capacity, monitoring, and logging your Lambda functions
- Lambda use cases
    - web backends
    - IoT backends
    - mobile backends
    - file or data processing
    - parallelizing computing tasks - splitting highly complex, long-lived computations to multiple smaller tasks across many Lambda function instances
    - stream or message processing
- if you need to manage your own compute resources
    - EC2
        - You get to choose
            - instance types
            - OS and customize it
            - settings for network and security
            - the entire software stack
        - You are responsible for
            - provisioning capacity
            - monitoring fleet health and performance
            - using AZs for fault tolerance
    - AWS Elastic Beanstalk
        - deploy and scale apps on EC2
        - you own and control underlying EC2 instances

### Amazon API Gateway
- in this use case we needed a way to expose the __backend Lambda function__
- __API Gateway__ integrates with Lambda, thus providing __a way to expose the backend service without exposing to the open internet__
- __fully managed__, making it easier for API developers to
    - create
    - publish
    - maintain
    - monitor
    - secure
    ...their APIs at scale
- supports
    - containerized worloads
    - serverless workloads
    - web apps
- Features
    - accepts and processes 1000s of concurrent API calls
    - traffic management
    - CORS support
    - access control and authorization
    - throttling
    - monitoring
    - API version management
- you can create
    - HTTP APIs are the best choice for building APIs that only require API proxy functionality - cheaper
    - REST APIs support API proxy functionality and API management features - costlier
    - WebSocket APIs that enable real-time two-way communication
- tiered pricing model and cost reduces as API usage scales

### Amazon EC2
- for this customer's use case EC2 brings in operational overhead
- here, customer was willing to rewrite the code to use Lambda
- spiky demand - choosing a service such as Lambda minimizes idling resources during low volume times, which can be more difficult to achieve with Amazon EC2
- hence EC2 was not chosen!

### AWS container services
- __Container management tools can be divided into three categories__
    - __registry__ - secure place to store and manage your container images
    - __orchestration__ - manages when and where your containers run
    - __compute__ - flexible compute engines to power your containers
- customer did not want to integrate this technology into their stack
    - running a container on Amazon ECS using AWS Fargate as the compute platform would technically work
    - it was not chosen because of customer preferences
- __Amazon ECS__
    - fully managed container orchestration service that you can use to deploy, manage, and scale containerized applications
    - run container workloads in the cloud or on premises
    - __Serverless by default with AWS Fargate__
        - Fargate is built into Amazon ECS, and it reduces the time you need to spend on
            - managing servers
            - handling capacity planning (scaling as needed)
            - figuring out how to isolate container workloads for security
        - define your application's requirements and __select Fargate as your launch type__
    - __Security and isolation by design__
        - integrates with the tools you already trust for security, identity, and management and governance
        - you can assign granular permissions for each of your containers, giving you a high level of isolation when you build your apps
    - __Autonomous control plane operations__
        - AWS configuration and operational best practices built-in—with no control plane, nodes, or add-ons for you to manage. It natively integrates with both AWS and third-party tools to make it easier for teams to focus on building the applications, not the environment.
- __Amazon EKS__
    - managed service to run Kubernetes on AWS without needing to install, operate, and maintain your own Kubernetes control plane or nodes
    - Kubernetes is an open-source system for automating the deployment, scaling, and management of containerized applications
    - runs and scales the Kubernetes control plane across multiple AWS AZs to ensure high availability
    - automatically scales control plane instances based on load, detects and replaces unhealthy control plane instances, and provides automated version updates and patching for them
    - integrated with many AWS services to provide scalability and security for your applications, including the following capabilities
        - Amazon ECR for container images
        - ELB for load distribution
        - IAM for authentication
        - VPC for isolation
    - runs latest version of Kubernetes, so you can use all of the existing plugins and tooling from the Kubernetes community
    - Apps that run on EKS are fully compatible with apps that run on any standard Kubernetes environment
        - __you can migrate any standard Kubernetes application to EKS without code changes__!
- __AWS Fargate__
    - use with ECS to run containers without managing servers or clusters of EC2 instances
    - reduces your need to provision, configure, or scale clusters of VMs to run containers
    - minimizes your need to choose server types, decide when to scale your clusters, or optimize cluster packing
    - Fargate launch type
        - you package your app in containers
        - specify the CPU and memory requirements
        - define networking and IAM policies
        - launch the application
    - With Amazon ECS on AWS Fargate capacity providers, you can use
        - Fargate
        - Fargate Spot
            - you can run __interruption-tolerant ECS tasks__ at a discounted rate
            - runs tasks on spare compute capacity - your tasks will be interrupted with a 2-minute warning notice

## Choosing an AWS Database Service
- Some options for DB service
    - Check the table of various services and their use cases on this page - https://aws.amazon.com/products/databases/
    - RDS is managed
        - 6 DB options
        - of this Amazon Aurora is also available serverless!
    - Dynamo DB is full managed key-value store and is also serverless!
    - more DB options like Neptune (graph DB), key-value in-memory DB (ElastiCache etc.) etc. are available
- we consider __Aurora Serverless__ and Dynamo DB as the 2 options
    - Aurora in an RDBMS and supports massive scalabiliy and performance for commercial RDBMS workloads
    - DynamoDB is also serverless and designed for scalability and performance
    - we focus on the app's storage patterns and throughput needs (how much data you read/write per second)
        - __provisioned mode__ - allocate storage based on estimated throughput (you allocate an upper bound)
            - good for relatively stable number of requests
        - __on-demand mode__ - allocate/deallocate storage on-the-go as throughput changes
            - good for spiky access
    - RDS Proxy to handle when many connections are made to the DB through multiple Lambdas
        - with Aurora we need an RDS proxy
        - This is especially needed when there is heavy traffic (like sales events)
        - this RDS proxy is an additional piece to be managed
        - with Dynamo DB, an RDS proxy is not needed (handling large number of connections is built-in)
    - with Dynamo DB
        - joins not supported
        - model the table with secondary indexes to speed-up queries in your app
    - orders service uses just one table. Both Aurora and Dynamo DB fit the bill, but Dynamo DB looks like a better fit for this use case as it makes the design simple, and yet effective for this use case
- So, which one to use?
    - ask the customer!
    - __customer confirmed there are no complex queries, and no joins (in fact as originally stated there is only 1 table)__
- So...Dynamo DB seems the winner (may need more thought)

## Reading 1.3: Databases on AWS
- are purpose-built
    - each DB serice is built for specific use cases
    - we chose DynamoDB as the customer is using it as a simple lookup table - no need for complex SQL queries or joins across tables
    - also serverless nature of the table makes it easy to operate over time
- __Amazon Aurora__
    - use the code, tools, and applications for your existing MySQL and PostgreSQL DBs with Aurora
    - includes a high-performance storage subsystem
    - its MySQL-compatible and PostgreSQL-compatible DB engines are __customized to take advantage of that fast, distributed storage__
    - storage grows automatically as needed
        - Aurora cluster volume can grow to a maximum size of 128 tebibytes (TiB)
    - automates and standardizes database clustering and replication, which is a challenging aspect of DB configuration and administration
    - Multi AZ deployment and multi-region replication support
- __Aurora Serverless v2__
    - on-demand, automatic scaling configuration for Aurora
    - automate monitoring workloads
    - automate scaling based on application demand
        - especially valuable for
            - multitenant DBs
            - distributed DBs
            - development and test systems
            - other environments with highly variable and unpredictable workloads
- __Amazon RDS Proxy__
    - __pool and share DB connections__ to improve their ability to scale
    - helps apps handle unpredictable surges in DB traffic by limiting number of connections
    - makes apps more resilient to DB failures by automatically connecting to a standby DB instance, while preserving connections
    - you can also enforce IAM authentication for DBs
    - securely store credentials in AWS Secrets Manager
    - queues / throttles application connections that can't be served immediately from the pool of connections
        - latencies might increase but your app can scale without failures
    - enable RDS Proxy for most apps with no code changes
- __Amazon DynamoDB__
    - fully managed NoSQL DB service
    - fast and predictable performance
    - seamless scalability
    - reduce need to handle
        - hardware provisioning
        - setup and configuration
        - software patching
        - replication
        - cluster scaling
    - offers encryption at rest
    - Multi AZ deployment and multi-region replication support
    - DynamoDB core components
        - tables
        - items
        - attributes
    - uses primary key to identify each item uniquely
    - secondary indexes to provide querying flexibility
    - use __DynamoDB Streams to capture data modification events in DynamoDB tables__

## Building Event-Driven Architectures
- pub-sub model for communication (event brokering) between decoupled microservices
- Parts
    - __producers__ publish (create) events
    - __event router__ ingests, filters and pushes the events to the appropriate consumers
    - __consumers__ subscribe to and consume events as they occur
- scale and fail services independently
- no need to poll, filter and route events in services themselves (reducing coupling)
- removes need for heavy coordination between services
- decide which services can publish/subscribe to the event router
    - also which users and resources have permission to access data
- encrypt events both in transit and at rest
- is push-based
    - no polling means less network bandwidth consumption, less CPU utilization, less idle fleet capacity, and less SSL/TLS handshakes
- __Two main types of event routers used in event-driven architectures__
    - __Event buses__
        - __Amazon EventBridge__
        - serverless
        - https://aws.amazon.com/eventbridge/
    - __Event topics__
        - __Amazon Simple Notification Service (SNS)__
        - serverless
        - https://aws.amazon.com/sns/
    - __EventBridge is more recent and full-fledged in terms of features compared to SNS__
        - supports lot more targets (producers and consumers) than SNS including
            - SaaS apps
        - supports filtering based on rules, whereas SNS supports only based on message attributes
        - has Schema Registry which has information about title, format, validation rules for event data
    - [AWS SQS vs SNS vs Eventbridge – When to Use What?](https://www.beabetterdev.com/2021/09/10/aws-sqs-vs-sns-vs-eventbridge/)
    - [AWS — Difference between Amazon EventBridge and Amazon SNS](https://medium.com/awesome-cloud/aws-difference-between-amazon-eventbridge-and-amazon-sns-comparison-aws-eventbridge-vs-aws-sns-46708bf5313)
- since our use case is simple, SNS will do
    - SNS is cheaper and simpler
- next question is how are we going to capture the order event that occurs when an order is received and Lambda stores it in Dynamo DB?
    - Answer: DynamoDB streams!
        - you can configure a DynamoDB table to trigger an event (in a stream) when a change is made
        - in this case another Lambda function can be set uo process this stream
        - the Lambda will publish an event to an SNS topic
        - the mechanism of sending the message to SNS is completely decoupled from the orders service
        - a new downstream service which may need to be invoked in future, for example, can also simply subscribe to the SNS topic

## SNS Exploration
Nothing special - took through the AWS console for creating a topic, configuring access rules, how subscriptions are made

## Reading 1.4: Event-Driven Architectures on AWS
- customer currently uses a synchronous web application to host the orders service, which is causing various issues
- event-driven architecture uses events to invoke and communicate between decoupled services
- sample events
    - placing an item in a shopping cart
- events can either
    - carry the state (the item purchased, its price, and a delivery address)
    - be identifiers (a notification that an order was shipped)
- producer services and consumer services are decoupled, which means that they can be scaled, updated, and deployed independently

### EventBridge vs SNS
- You can use both EventBridge and SNS to develop event-driven apps
    - choice depends on specific needs
- EventBridge is used when you want to build an app that reacts to
    - events from software as a service (SaaS) applications - integrates directly with third-party SaaS AWS Partners
    - AWS services - ingests events from over 90 AWS services without requiring developers to create any resources in their account
- uses a defined, JSON-based structure for events
- select events to forward to a target by creating rules that are applied across the entire event body
- supports over 15 AWS services as targets
    - Lambda
    - SQS
    - SNS
    - Kinesis Data Streams
    - Kinesis Data Firehose
- has a typical latency of about half a second
- __SNS is used when you
    - want to build an application that reacts to _high throughput_ or _low-latency messages___
    - SNS provides nearly unlimited throughput
    - use it for applications that need very high fan-out (thousands or millions of endpoints)
- SNS messages are unstructured and can be in any format
- SNS supports 6 services as targets
    - Lambda
    - SQS
    - HTTP/S endpoints
    - email
    - SMS
    - mobile push
- typical latency of SNS is under 30 ms

### Amazon EventBridge
- serverless event bus service
- connect your app with data from various sources
- targets
    - Lambda
    - HTTP invocation endpoints
    - event buses in other AWS accounts
    - etc.
- when it receives an __event__, it applies a rule to route the event to a target
- __rules__ match events to targets based
    - __event pattern__ - the structure of the event
    - on a schedule
    - eg. when an EC2 instance changes from pending to running, you can have a rule that sends the event to a Lambda function
- all events that come to EventBridge are associated with an __event bus__
    - __rules are tied to a single event bus__, so they can only be __applied to events on that event bus__
    - your account has a __default event bus__, which __receives events from AWS services__
    - you can also create __custom event buses__ to send or receive events from a different account or region

## Amazon SNS
- SNS now supports payload-based pattern message filtering (apart from the old attribute-based filtering)
    - https://aws.amazon.com/blogs/compute/introducing-payload-based-message-filtering-for-amazon-sns/

## Amazon DynamoDB Streams
- captures a time-ordered sequence of item-level modifications in any DynamoDB table
- stores this information in a log for up to 24 hours
    - data older than 24 hours is susceptible to trimming (removal) at any moment
- apps can view the log items as they appear and take action in real timew
- you can also capture __before__ and __after__ images of the modified items
- encryption at rest encrypts the data in the stream
- each stream record appears exactly one time in the stream
- DynamoDB Streams operates asynchronously
    - so table performance is not affected if you enable a stream

## Resources
- [AWS compute services](https://aws.amazon.com/products/compute/)
- [AWS Lambda FAQs](https://aws.amazon.com/lambda/faqs/)
- [Getting started with Lambda](https://docs.aws.amazon.com/lambda/latest/dg/getting-started.html)
- [AWS Lambda Developer Guide](https://docs.aws.amazon.com/lambda/latest/dg/welcome.html)
- [AWS Lambda Operator Guide](https://docs.aws.amazon.com/lambda/latest/operatorguide/intro.html)
- [AWS Lambda Architecture and Best Practices](https://docs.aws.amazon.com/lambda/latest/operatorguide/architecture-best-practice.html)
- [AWS Lambda - Technical Talks](https://aws.amazon.com/lambda/resources/webinars-and-talks/)
- [AWS Lambda - Workshops & Tutorials](https://aws.amazon.com/lambda/resources/workshops-and-tutorials/)
- [Serverless Developer Guide](https://docs.aws.amazon.com/serverless/latest/devguide/welcome.html)
- [Amazon API Gateway](https://aws.amazon.com/api-gateway/)
- [Amazon API gateway FAQs](https://aws.amazon.com/api-gateway/faqs/)
- [Tutorial: Get started with Amazon EC2](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EC2_GetStarted.html)
- [What is Amazon EC2?](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/concepts.html)
- [Amazon EC2 FAQs](https://aws.amazon.com/ec2/faqs/)
- [Amazon EKS User Guide](https://docs.aws.amazon.com/eks/latest/userguide/what-is-eks.html)
- [Containers on AWS](https://aws.amazon.com/containers/services/)
- [Amazon ECS on AWS Fargate](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/AWS_Fargate.html)
- [Amazon ECS Workshop](https://ecsworkshop.com/)
- [YouTube channel - Containers from the Couch - Live streams and videos featuring AWS Container Services and demos](https://www.youtube.com/containersfromthecouch)
- [AWS Cloud Databases](https://aws.amazon.com/products/databases/)
- [AWS Cloud Databases](https://aws.amazon.com/products/databases/)
- [Using Aurora Serverless v2](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless-v2.html)
- [Getting started with Amazon Aurora](https://aws.amazon.com/rds/aurora/getting-started/)
- [Using Amazon RDS Proxy](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/rds-proxy.html)
- [What is Amazon DynamoDB?](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Introduction.html)
- [Amazon DynamoDB FAQs](https://aws.amazon.com/dynamodb/faqs/)
- [Example of modeling relational data in DynamoDB](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-modeling-nosql-B.html)
- [Hands-on labs for DynamoDB](https://catalog.workshops.aws/dynamodb-labs/en-US/hands-on-labs)
- [What is an Event-Driven Architecture?](https://aws.amazon.com/event-driven-architecture/)
- [Amazon EventBridge](https://aws.amazon.com/eventbridge/)
- [Amazon Simple Notification Service (SNS)](https://aws.amazon.com/sns/)
- [AWS SQS vs SNS vs Eventbridge – When to Use What?](https://www.beabetterdev.com/2021/09/10/aws-sqs-vs-sns-vs-eventbridge/)
- [AWS — Difference between Amazon EventBridge and Amazon SNS](https://medium.com/awesome-cloud/aws-difference-between-amazon-eventbridge-and-amazon-sns-comparison-aws-eventbridge-vs-aws-sns-46708bf5313)
- [What is Amazon EventBridge?](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-what-is.html)
- [Amazon EventBridge FAQs](https://aws.amazon.com/eventbridge/faqs/)
- [Amazon EventBridge events](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-events.html)
- [Amazon EventBridge rules](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-rules.html)
- [Amazon EventBridge event patterns](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-event-patterns.html)
- [Amazon EventBridge event buses](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-event-bus.html)
- [Payload-based message filtering support in SNS](https://aws.amazon.com/blogs/compute/introducing-payload-based-message-filtering-for-amazon-sns/)
- [What is Amazon SNS?](https://docs.aws.amazon.com/sns/latest/dg/welcome.html)
- [Amazon SNS FAQs](https://aws.amazon.com/sns/faqs/)
- [Getting started with Amazon SNS](https://docs.aws.amazon.com/sns/latest/dg/sns-getting-started.html#step-create-queue)
- [Change data capture for DynamoDB Streams](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.html)
- [Tutorial: Process new items with DynamoDB Streams and Lambda](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.Lambda.Tutorial.html)
