# Week 1 - Designing a serverless web backend on AWS

## Customer #1: Use Case and Requirements
- Have used lift-and-shift to migrate to AWS so fay
- looking to use cloud-native (AWS-native) technologies now
- e-commerce store with website and app
    - customer shops
    - customer can also purchase wholesale, for selling in their retail stores
    - __orders service__ accepts orders from web and mobile and is __hosted on-premise__
        - authenticates, validates and accepts (or rejects) orders, processes them, and stores them in the DB
        - calls downstream services like
            - inventory service
            - fulfilment service
            - accounting service
            - __these downstream services are already on AWS!__
        - __Assumption__: Payment has already been processed using a payment gateway, before the order service is invoked
    - web server accepting order requests and application server are right now the same
    - __uses a MySQL DB on-premise__
    - downstream services work with their own DB
    - open to migrating DB
    - DB required to be highly available and durable
    - order details are right now maintained in only 1 table! - data is minimal and maintaining a whole DB seems overkill
    - what are the current pain points that are driving rewrite/re-architecting rather than lift-and-shift?
        - when there are large number of orders, service is unable to handle it, and orders get dropped
            - i.e. scaling quickly on-demand on-premise is a problem currently
            - looking for automatic scaling
        - sometimes some downstream service calls are completed but others are not as order service crashes before order completion
            - eg. call to inventory service completed
            - before its result could be processed by the order service (and calls made to fulfilment and accounting), the order service crashes
                - __problem is the services are tightly coupled__
            - need is to decouple the services to increase resilience of the app
        - result in loss of orders, inconsistency in orders data for customers
    - app encounters spiky demand from customers (as opposed to low/high volume steady/cyclical demand)
        - demand increases when coupons are sent out, or as part of sales campaigns
        - otherwise close to no demand
        - right now on-premise data center needs to over-provision resources
    - company is open to rewrite code to go cloud-native
    - need monitoring and logging, and common logging system throughout the app
    - need to optimize the solution for cost and performance
        
## Customer #1: Requirements Breakdown
- migrating from on-premises to SOA on AWS
- orders service is built as a monolith
- web server, orders service, DB are in scope of migration
    - 3 downstream services are out-of-scope
- service needs to be more resilient
    - failure of one part of the app does not affect other parts
    - suggests loose-coupling through event-driven architecture
- manage scaling for DB and compute
    - suggests serverless architecture as its fully-managed!
- centralized monitoring and logging
    - serverless services are already well-integrated with CloudWatch and CloudWatch Logs
- optimizing for cost, performance efficiency, operational overhead
    - __cost shall be the main driver for choice of services__
    - __performance efficiency, operational overhead are secondary drivers for the choices__
    - again serverless optimizes these factors in this priority!
    - also, once we architect we can review various choices of servies and see how to optimize further for these 3 factors

## Selecting a Serverless Compute Service
- Some options for compute service
    - Check the table of various services and their use cases on this page - https://aws.amazon.com/products/compute/
    - EC2
    - Lightsail
    - ECS
    - EKS
    - Fargate
    - Lambda
- EC2 could be used for lift-and-shift requirement. But it involves some management on customer's parts - in this case customer does not want to manage servers
- Container orchestration services like ECS, EKS can run containers on EC2 (unmanaged) or Fargate (managed)
    - Fargate is a good choice for this requirement as
        - it is managed
        - logs and metrics go to CloudWatch
        - no idle instances (managed scaling)
    - But we are _not sure if customer is interested in using containers_!
- __Lambda is _cloud-native___ - i.e. designed to take advantage of all the services the AWS cloud has to offer!
    - serverless (managed)
    - logs and metrics go to CloudWatch
    - some configurations still need to be maintained and tweaked over time
    - some things you may still need to do to make scaling happen faster, code run faster
    - but these operational overheads are still minimal compared to EC2
    - When an event triggers a function, Lambda 
        - runs the task on a micro-VM called Firecracker (called the `execution environment`)
        - shuts down the VM if it idling for a period of time
- So, which one to use?
    - ask the customer!
    - __customer says there aren't people skilled enough to use containers__!
- So...Lambda is the winner
    - orders service needs to be rewritten to a set of functions that can be invoked by Lambda
        - but that is not much difference or much work!
    - also __triggers for functions need to be configured__
        - a trigger for Lambda can be
            - SQS message being enqueued
            - HTTP/HTTPS request from API Gateway
            - request via ELB
            - etc.
- We can choose __Amazon API Gateway for the web server__ and can
    - forward incoming HTTP/HTTPS requests for orders service endpoints
    - handle authentiction requests
    - handle request validation
    - managed scalable
    - like Lambda logs and metrics go to CloudWatch!

## AWS Lambda Exploration
- Create a function
    - name it
    - choose runtime (like java 8, .NET 6, Node 16 etc.)
        - you can even choose a custom runtime if the off-the-shelf supported does not have what you need
    - create an IAM role that the Lambda can assume when it executes the function
        - this defines what services are available to the Lambda (or rather the function running on it)
    - enable VPC if you want to communicate with a resource in a private VPC (eg. an RDS DB)
    - add trigger
        - triggers can be AWS services
        - using Amazon aws/eventbridge, you can even trigger from many popular third-party SaaS services like Auth0, Datadog, Freshworks, MongoDB etc.
        - eg. set up an API Gateway with an API to invoke the function - this creates an HTTP/REST endpoint (as you choose)
    - code signing
        - only approved developers publish unaltered, trusted code in your functions
    - the function can be uploaded, defined in the code editor (`Code` tab)
        - gets `event`, `context` as arguments
            - event has details of payload of the request
            - context of the execution
        - code is stored in S3 with encryption at rest
            - integrity checks are performed when code is used
        - code should be __stateless__
            - should assume no affinity to the underlying compute infrastructure
            - local file system access, child processes cannot extend beyond the lifetime of the request
                - 512MB of instance's own ephemeral storage is free of cost
                - you can configure between 512MB - 10,240MB, in 1MB increments (`/tmp` directory) at a price
                - CloudWatch can be used to monitor ephemeral storage usage!
            - persistent state should be stored in S3, DynamoDB, RDS, EFS, or another internet-available storage service
        - manage versions
            - eg. a new version of a function can be used for beta testing without affecting users of the stable production version
    - logs can be
        - runtime logs (eg. details of invocation)
        - application logs (that the function logs)
    - the `Test` tab can be used to make an HTTP request for testing the execution
    - add destination

## Reading 1.2: Compute on AWS
- before selecting any service, ensure that you are up to date on any new AWS service or feature releases
- [High-level overview of the different AWS compute services for any worload](https://aws.amazon.com/products/compute/)

### AWS Lambda
- Lambda functions can run for up to 15 minutes
    - __any processes that needs > 15 minutes should use other compute services on AWS__!
- metered in 1ms increments
- each execution environment stays active for a period of time, and then it shuts down on its own
- managed nature makes it easier to optimize for operational efficiency and have low operational overhead
    - Lambda manages the compute fleet, which offers a balance of memory, CPU, network, and other resources to run your code
    - you can't log in to compute instances, customize OS etc.
    - Lambda manages capacity, monitoring, and logging your Lambda functions
- Lambda use cases
    - web backends
    - IoT backends
    - mobile backends
    - file or data processing
    - parallelizing computing tasks - splitting highly complex, long-lived computations to multiple smaller tasks across many Lambda function instances
    - stream or message processing
- if you need to manage your own compute resources
    - EC2
        - You get to choose
            - instance types
            - OS and customize it
            - settings for network and security
            - the entire software stack
        - You are responsible for
            - provisioning capacity
            - monitoring fleet health and performance
            - using AZs for fault tolerance
    - AWS Elastic Beanstalk
        - deploy and scale apps on EC2
        - you own and control underlying EC2 instances

### Amazon API Gateway
- in this use case we needed a way to expose the __backend Lambda function__
- __API Gateway__ integrates with Lambda, thus providing __a way to expose the backend service without exposing to the open internet__
- __fully managed__, making it easier for API developers to
    - create
    - publish
    - maintain
    - monitor
    - secure
    ...their APIs at scale
- supports
    - containerized worloads
    - serverless workloads
    - web apps
- Features
    - accepts and processes 1000s of concurrent API calls
    - traffic management
    - CORS support
    - access control and authorization
    - throttling
    - monitoring
    - API version management
- you can create
    - HTTP APIs are the best choice for building APIs that only require API proxy functionality - cheaper
    - REST APIs support API proxy functionality and API management features - costlier
    - WebSocket APIs that enable real-time two-way communication
- tiered pricing model and cost reduces as API usage scales

### Amazon EC2
- for this customer's use case EC2 brings in operational overhead
- here, customer was willing to rewrite the code to use Lambda
- spiky demand - choosing a service such as Lambda minimizes idling resources during low volume times, which can be more difficult to achieve with Amazon EC2
- hence EC2 was not chosen!

### AWS container services
- __Container management tools can be divided into three categories__
    - __registry__ - secure place to store and manage your container images
    - __orchestration__ - manages when and where your containers run
    - __compute__ - flexible compute engines to power your containers
- customer did not want to integrate this technology into their stack
    - running a container on Amazon ECS using AWS Fargate as the compute platform would technically work
    - it was not chosen because of customer preferences
- __Amazon ECS__
    - fully managed container orchestration service that you can use to deploy, manage, and scale containerized applications
    - run container workloads in the cloud or on premises
    - __Serverless by default with AWS Fargate__
        - Fargate is built into Amazon ECS, and it reduces the time you need to spend on
            - managing servers
            - handling capacity planning (scaling as needed)
            - figuring out how to isolate container workloads for security
        - define your application's requirements and __select Fargate as your launch type__
    - __Security and isolation by design__
        - integrates with the tools you already trust for security, identity, and management and governance
        - you can assign granular permissions for each of your containers, giving you a high level of isolation when you build your apps
    - __Autonomous control plane operations__
        - AWS configuration and operational best practices built-in—with no control plane, nodes, or add-ons for you to manage. It natively integrates with both AWS and third-party tools to make it easier for teams to focus on building the applications, not the environment.
- __Amazon EKS__
    - managed service to run Kubernetes on AWS without needing to install, operate, and maintain your own Kubernetes control plane or nodes
    - Kubernetes is an open-source system for automating the deployment, scaling, and management of containerized applications
    - runs and scales the Kubernetes control plane across multiple AWS AZs to ensure high availability
    - automatically scales control plane instances based on load, detects and replaces unhealthy control plane instances, and provides automated version updates and patching for them
    - integrated with many AWS services to provide scalability and security for your applications, including the following capabilities
        - Amazon ECR for container images
        - ELB for load distribution
        - IAM for authentication
        - VPC for isolation
    - runs latest version of Kubernetes, so you can use all of the existing plugins and tooling from the Kubernetes community
    - Apps that run on EKS are fully compatible with apps that run on any standard Kubernetes environment
        - __you can migrate any standard Kubernetes application to EKS without code changes__!
- __AWS Fargate__
    - use with ECS to run containers without managing servers or clusters of EC2 instances
    - reduces your need to provision, configure, or scale clusters of VMs to run containers
    - minimizes your need to choose server types, decide when to scale your clusters, or optimize cluster packing
    - Fargate launch type
        - you package your app in containers
        - specify the CPU and memory requirements
        - define networking and IAM policies
        - launch the application
    - With Amazon ECS on AWS Fargate capacity providers, you can use
        - Fargate
        - Fargate Spot
            - you can run __interruption-tolerant ECS tasks__ at a discounted rate
            - runs tasks on spare compute capacity - your tasks will be interrupted with a 2-minute warning notice

## Choosing an AWS Database Service
- Some options for DB service
    - Check the table of various services and their use cases on this page - https://aws.amazon.com/products/databases/
    - RDS is managed
        - 6 DB options
        - of this Amazon Aurora is also available serverless!
    - Dynamo DB is full managed key-value store and is also serverless!
    - more DB options like Neptune (graph DB), key-value in-memory DB (ElastiCache etc.) etc. are available
- we consider __Aurora Serverless__ and Dynamo DB as the 2 options
    - Aurora in an RDBMS and supports massive scalabiliy and performance for commercial RDBMS workloads
    - DynamoDB is also serverless and designed for scalability and performance
    - we focus on the app's storage patterns and throughput needs (how much data you read/write per second)
        - __provisioned mode__ - allocate storage based on estimated throughput (you allocate an upper bound)
            - good for relatively stable number of requests
        - __on-demand mode__ - allocate/deallocate storage on-the-go as throughput changes
            - good for spiky access
    - RDS Proxy to handle when many connections are made to the DB through multiple Lambdas
        - with Aurora we need an RDS proxy
        - This is especially needed when there is heavy traffic (like sales events)
        - this RDS proxy is an additional piece to be managed
        - with Dynamo DB, an RDS proxy is not needed (handling large number of connections is built-in)
    - with Dynamo DB
        - joins not supported
        - model the table with secondary indexes to speed-up queries in your app
    - orders service uses just one table. Both Aurora and Dynamo DB fit the bill, but Dynamo DB looks like a better fit for this use case as it makes the design simple, and yet effective for this use case
- So, which one to use?
    - ask the customer!
    - __customer confirmed there are no complex queries, and no joins (in fact as originally stated there is only 1 table)__
- So...Dynamo DB is the winner (this decision may need more thought in general)

## DynamoDB Exploration
- Creating a table
    - name
    - parition key
        - primary key
        - mandatory
    - sort key
        - if parition key is not unique, you can make it unique by tagging along the sort key as well!
        - optional
        - allows you to sort or search among all items sharing the same partition key
    - secondary indexes
        - local
        - global
    - capacity mode
        - provisioned
            - best to configure with auto-scaling, else you end up over-allocating DB resource
            - free-tier eligible
            - you can reserve capacity and this brings down costs to an extent
            - predictable workloads
            - gradual ramp up of traffic and not spiky
        - on-demand
            - apart from overcmong above disadvantages, this can be used to track DB traffic through CloudWatch, and then right-size and provision capacity
    - Read capacity measured in Read Capacity Units (RCU)
        - default 5, but you can change
    - Write capacity measured in Write Capacity Units (WCU)
        - default 5, but you can change
    - These units determine throughput
    - For more information about RCU and WCU - https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html
    - table classes
        - Standard
        - Standard-IA (Infrequent Access)
    - __Monitor__ tab is used to configure and manage CloudWatch metrics
    - __Exports and streams__ - to configure export to S3, Kinesis and Dynamo DB streams
    - __Global tables__ tab is used to create replicas in other regions
    

## Reading 1.3: Databases on AWS
- are purpose-built
    - each DB serice is built for specific use cases
    - we chose DynamoDB as the customer is using it as a simple lookup table - no need for complex SQL queries or joins across tables
    - also serverless nature of the table makes it easy to operate over time
- __Amazon Aurora__
    - use the code, tools, and applications for your existing MySQL and PostgreSQL DBs with Aurora
    - includes a high-performance storage subsystem
    - its MySQL-compatible and PostgreSQL-compatible DB engines are __customized to take advantage of that fast, distributed storage__
    - storage grows automatically as needed
        - Aurora cluster volume can grow to a maximum size of 128 tebibytes (TiB)
    - automates and standardizes database clustering and replication, which is a challenging aspect of DB configuration and administration
    - Multi AZ deployment and multi-region replication support
- __Aurora Serverless v2__
    - on-demand, automatic scaling configuration for Aurora
    - automate monitoring workloads
    - automate scaling based on application demand
        - especially valuable for
            - multitenant DBs
            - distributed DBs
            - development and test systems
            - other environments with highly variable and unpredictable workloads
- __Amazon RDS Proxy__
    - __pool and share DB connections__ to improve their ability to scale
    - helps apps handle unpredictable surges in DB traffic by limiting number of connections
    - makes apps more resilient to DB failures by automatically connecting to a standby DB instance, while preserving connections
    - you can also enforce IAM authentication for DBs
    - securely store credentials in AWS Secrets Manager
    - queues / throttles application connections that can't be served immediately from the pool of connections
        - latencies might increase but your app can scale without failures
    - enable RDS Proxy for most apps with no code changes
- __Amazon DynamoDB__
    - fully managed NoSQL DB service
    - fast and predictable performance
    - seamless scalability
    - reduce need to handle
        - hardware provisioning
        - setup and configuration
        - software patching
        - replication
        - cluster scaling
    - offers encryption at rest
    - Multi AZ deployment and multi-region replication support
    - DynamoDB core components
        - tables
        - items
        - attributes
    - uses primary key to identify each item uniquely
    - secondary indexes to provide querying flexibility
    - use __DynamoDB Streams to capture data modification events in DynamoDB tables__

## Building Event-Driven Architectures
- pub-sub model for communication (event brokering) between decoupled microservices
- Parts
    - __producers__ publish (create) events
    - __event router__ ingests, filters and pushes the events to the appropriate consumers
    - __consumers__ subscribe to and consume events as they occur
- scale and fail services independently
- no need to poll, filter and route events in services themselves (reducing coupling)
- removes need for heavy coordination between services
- decide which services can publish/subscribe to the event router
    - also which users and resources have permission to access data
- encrypt events both in transit and at rest
- is push-based
    - no polling means less network bandwidth consumption, less CPU utilization, less idle fleet capacity, and less SSL/TLS handshakes
- __Two main types of event routers used in event-driven architectures__
    - __Event buses__
        - __Amazon EventBridge__
        - serverless
        - https://aws.amazon.com/eventbridge/
    - __Event topics__
        - __Amazon Simple Notification Service (SNS)__
        - serverless
        - https://aws.amazon.com/sns/
    - __EventBridge is more recent and full-fledged in terms of features compared to SNS__
        - supports lot more targets (producers and consumers) than SNS including
            - SaaS apps
        - supports filtering based on rules, whereas SNS supports only based on message attributes
        - has Schema Registry which has information about title, format, validation rules for event data
    - [AWS SQS vs SNS vs Eventbridge – When to Use What?](https://www.beabetterdev.com/2021/09/10/aws-sqs-vs-sns-vs-eventbridge/)
    - [AWS — Difference between Amazon EventBridge and Amazon SNS](https://medium.com/awesome-cloud/aws-difference-between-amazon-eventbridge-and-amazon-sns-comparison-aws-eventbridge-vs-aws-sns-46708bf5313)
- since our use case is simple, SNS will do
    - SNS is cheaper and simpler
- next question is how are we going to capture the order event that occurs when an order is received and Lambda stores it in Dynamo DB?
    - Answer: DynamoDB streams!
        - you can configure a DynamoDB table to trigger an event (in a stream) when a change is made
        - in this case another Lambda function can be set uo process this stream
        - the Lambda will publish an event to an SNS topic
        - the mechanism of sending the message to SNS is completely decoupled from the orders service
        - a new downstream service which may need to be invoked in future, for example, can also simply subscribe to the SNS topic

## SNS Exploration
Nothing special - took through the AWS console for creating a topic, configuring access rules, how subscriptions are made

## Reading 1.4: Event-Driven Architectures on AWS
- customer currently uses a synchronous web application to host the orders service, which is causing various issues
- event-driven architecture uses events to invoke and communicate between decoupled services
- sample events
    - placing an item in a shopping cart
- events can either
    - carry the state (the item purchased, its price, and a delivery address)
    - be identifiers (a notification that an order was shipped)
- producer services and consumer services are decoupled, which means that they can be scaled, updated, and deployed independently

### EventBridge vs SNS
- You can use both EventBridge and SNS to develop event-driven apps
    - choice depends on specific needs
- EventBridge can have multiple source applications as producers simultaneously generating events, SNS can have only 1 producer
    - __Note__: This needs to be better understood (@todo)
- EventBridge is used when you want to build an app that reacts to
    - events from software as a service (SaaS) applications - integrates directly with third-party SaaS AWS Partners
    - AWS services - ingests events from over 90 AWS services without requiring developers to create any resources in their account
- uses a defined, JSON-based structure for events
- select events to forward to a target by creating rules that are applied across the entire event body
- supports over 15 AWS services as targets
    - Lambda
    - SQS
    - SNS
    - Kinesis Data Streams
    - Kinesis Data Firehose
- has a typical latency of about half a second
- __SNS is used when you
    - want to build an application that reacts to _high throughput_ or _low-latency messages___
    - SNS provides nearly unlimited throughput
    - use it for applications that need very high fan-out (thousands or millions of endpoints)
- SNS messages are unstructured and can be in any format
- SNS supports 6 services as targets
    - Lambda
    - SQS
    - HTTP/S endpoints
    - email
    - SMS
    - mobile push
- typical latency of SNS is under 30 ms

### Amazon EventBridge
- serverless event bus service
- connect your app with data from various sources
- targets
    - Lambda
    - HTTP invocation endpoints
    - event buses in other AWS accounts
    - etc.
- when it receives an __event__, it applies a rule to route the event to a target
- __rules__ match events to targets based
    - __event pattern__ - the structure of the event
    - on a schedule
    - eg. when an EC2 instance changes from pending to running, you can have a rule that sends the event to a Lambda function
- all events that come to EventBridge are associated with an __event bus__
    - __rules are tied to a single event bus__, so they can only be __applied to events on that event bus__
    - your account has a __default event bus__, which __receives events from AWS services__
    - you can also create __custom event buses__ to send or receive events from a different account or region

## Amazon SNS
- Again, fans out messages to multiple consumers
- Works with a push mechanism
- SNS now supports payload-based pattern message filtering (apart from the old attribute-based filtering)
    - https://aws.amazon.com/blogs/compute/introducing-payload-based-message-filtering-for-amazon-sns/

## Amazon DynamoDB Streams
- captures a time-ordered sequence of item-level modifications in any DynamoDB table
- stores this information in a log for up to 24 hours
    - data older than 24 hours is susceptible to trimming (removal) at any moment
- apps can view the log items as they appear and take action in real timew
- you can also capture __before__ and __after__ images of the modified items
- encryption at rest encrypts the data in the stream
- each stream record appears exactly one time in the stream
- DynamoDB Streams operates asynchronously
    - so table performance is not affected if you enable a stream

## Decoupling AWS Solutions
- response to placing orders is right now slow
    - customer wants to speed it up
- instead of the the usual 3-tier architecture flow, re-architect the app using a __storage first__ model
    - as soon as an order request is received, store the order data received somewhere, and respond to the user
- Use the superpowers of API Gateway to achieve this
    - supports data __transformation__ and __validation__
        - __we can move such logic from the compute layer to the API Gateway!__
    - integrates with AWS services
        - store in Dynamo DB
        - send message to SQS queue, or publish it to SNS
        - no need for a Lambda function to do these tasks
- Two options
    - if there is no business logic except simple transformation and validation, we can get rid of the Lambda entirely, and use API Gateway to store the order details in Dynamo DB
    - else, we can have API Gateway publish the order details to an SQS queue, and the Lambda can read the message asynchronously from the queue, and process and store the order like before in DynamoDB
    - both options are resilient (orders are not dropped), scale well and do so automatically (all are serverless building services!)
- So, which one to use?
    - ask the customer!
    - __customer confirmed there is complex business logic at work__
- So...SQS option is the winner

## SQS Exploration
- SQS works by polling whereas SNS works with a push mechanism
- Unlike SNS, the message is retained in the queue until subscriber reads it
    - in SNS, it is sent as the event occurs, and the subscriber is reponsible to receive and maintain it if needed till it can process it
- __Queue configurations__
    - __queue type__
        - Similar to SNS, you have __Standard__ and __FIFO queues__
    - __retention period__
        - message retained for this time, post which an unread message is dropped
        - default is 4 days
        - max configurable is 14 days
    - __message size__
        - < 256KB
        - for larger ones, store the message somewhere else (eg. database), and provide a reference
    - __receive wait time__
        - the polling duration
        - specify a  between 0 - 20 seconds
        - default is 0 seconds (which indicates short polling)
            - this is inefficient if you have infrequent messages
        - prefer larger values
    - __visibility timeout__
        - the length of time that a message received from the queue by one consumer will not be visible to another consumer!
            - default is 30 seconds
        - this gives a chance for a consumer to process and delete the message (if the use case is such that it is to be processed by only 1 consumer) within the timeout period, when other consumers should not processs it
            - set the timeout to the maximum time you expect the consumer to take to process and delete the message
    - __resource (access) policy__
        - set who can send / receive messages
    - __delivery delay__
        - the amount of time to delay before SQS delivers a message that is added to the queue (__SQS delay queues__)
    - __content-based deduplication__
        - SQS can automatically create deduplication IDs based on the body of the message
    - you can also subscribe the queue to an SNS topic
    - you can also set if this SQS queue should trigger a Lamba function
    - set up CloudWatch monitoring
    - supports __Dead-Letter Queues (DLQ)__
        - other queues (source queues) can target for messages that can't be processed (consumed) successfully
        - useful for debugging as you can isolate unconsumed messages to determine why their processing didn't succeed

## Reading 1.5: Decoupling Solutions on AWS
- loosely coupled architecture minimizes bottlenecks caused by synchronous communication, latency, and I/O operations
- SQS and Lambda are used to implement asynchronous communication between different services
- consider this pattern if
    - You want to create loosely coupled architecture
    - All operations don't need to be completed in a single transaction, and some operations can be asynchronous
    - the downstream system can't handle the incoming transactions per second (TPS) rate
    - the messages can be written to the queue and processed based on the availability of resources
- A __disadvantage of this pattern is that the actions of business transaction are synchronous__
    - even though the calling system receives a response, some part of the transaction might still continue to be processed by downstream systems
- [Patterns for integrating microservices](https://docs.aws.amazon.com/prescriptive-guidance/latest/modernization-integrating-microservices/integrating-patterns.html)
- [Building storage-first serverless apps with HTTP APIs service integrations](https://aws.amazon.com/blogs/compute/building-storage-first-applications-with-http-apis-service-integrations/)
- __Long polling benefits__
    - Reduces empty responses by letting Amazon SQS wait until a message is available in a queue before it sends a response.
    - Reduces false empty responses by querying all—instead of a subset of—Amazon SQS servers
    - Returns messages as soon as they become available

## Week Wrap-Up: Taking this Architecture to the Next Level
- __DynamoDB Accelerator (DAX)__
    - caching layer for DynamoDB
    - ensure you don't have DB hits for same query when repeated
    - you introduce it if needed (current performance is not good enough)
        - remember, it comes with a cost!
        - do some A/B testing - with DAX/without DAX!
- __AWS Lambda Power tuning library__
    - you can specify memory and CPU for your Lambdas
    - increasing resources may sometimes help save costs!
        - Lambdas are charged based on time they run - although we may deploy more resources (costlier per resource), but compute time may reduce, helping us save costs overall
    - this library helps determine the optimum resources for your workloads!
- __AWS Lambda Layers__
    - code that can be reused across multiple Lambda functions
    - eg. common libraries
        - you can create a Lambda layer for it and reference the layer through another Lambda function
        - __updates to only the library means updating ONLY that layer.__ neat!
        - __can speed up deployments as libraries do not need to be part of deployment__
- AWS Lambda also has a feature where objects shared between invocations can actually be created outside of the Lambda function execution, and reused everytime it runs
    - performant code!
- __AWS Lambda Powertools__
    - suite of utilitiees for Lambda functions
    - helps tracing, X Ray, custom metrics

## Reading 1.6: Architecture Optimizations for Week 1
- __Caching for Amazon DynamoDB by using Amazon DynamoDB Accelerator (DAX)__
    - fully managed, highly available, in-memory cache for DynamoDB
    - up to a 100-times performance improvement
        — from milliseconds to microseconds
    - developers don't need to manage
        - cache invalidation
        - data population
        - cluster management
    - no need to modify the application logic because DAX is compatible with existing DynamoDB API calls
- __AWS Lambda Power Tuning__
    - open-source tool that helps you visualize and fine-tune the memory or power configuration of Lambda functions in a data-driven way
    - is a language-agnostic state machine that's powered by __AWS Step Functions__ and is easy to deploy and fast to execute
        - to use it you provide a Lambda function Amazon Resource Name (ARN) as input
        - it then invokes that function with multiple power configurations (from 128 MB to 10 GB—you decide which values)
        - it analyzes all the execution logs and suggests the best power configuration to minimize cost or maximize performance
    - supports three optimization strategies
        - cost
        - speed
        - balanced
    - __input function will run in your AWS account!__
        - it will perform HTTP requests, SDK calls, cold starts, and so on
        - also supports cross-Region invocations, and you can enable parallel execution to generate results in a few seconds
        - generates a visualization of average cost and speed for each power configuration.
- __AWS Lambda Powertools__
    - suite of utilities for AWS Lambda functions __makes it easier to adopt best practices__ such as
        - tracing
        - structured logging
        - custom metrics
        - idempotency
        - batching
        - etc.
- __AWS Lambda execution environment reuse__
    - move certain initialization tasks in your code so they are outside the handler
        - can be reused across invocations
    - improves the performance of your function
    - example tasks
        - initialize SDK clients and database connections outside of the function handler
        - cache static assets locally in the /tmp directory
            - subsequent invocations that are processed by the same instance of your function can reuse these resources
            - also saves cost by reducing function run time
    - to avoid data leaks across invocations, __don't use the execution environment to store__
        - user data
        - events
        - other sensitive data

## Exercise 1 Walkthrough
- creates a PoC of the entire solution

## Challenge: Build a Proof of Concept
- Exercise 1. Architecting Solutions: Building a Proof of Concept for a Serverless Solution
- https://aws-tc-largeobjects.s3.us-west-2.amazonaws.com/DEV-AWS-MO-Architecting/exercise-1-serverless.html

## Resources
- [AWS compute services](https://aws.amazon.com/products/compute/)
- [AWS Lambda FAQs](https://aws.amazon.com/lambda/faqs/)
- [Getting started with Lambda](https://docs.aws.amazon.com/lambda/latest/dg/getting-started.html)
- [AWS Lambda Developer Guide](https://docs.aws.amazon.com/lambda/latest/dg/welcome.html)
- [AWS Lambda Operator Guide](https://docs.aws.amazon.com/lambda/latest/operatorguide/intro.html)
- [AWS Lambda Architecture and Best Practices](https://docs.aws.amazon.com/lambda/latest/operatorguide/architecture-best-practice.html)
- [AWS Lambda - Technical Talks](https://aws.amazon.com/lambda/resources/webinars-and-talks/)
- [AWS Lambda - Workshops & Tutorials](https://aws.amazon.com/lambda/resources/workshops-and-tutorials/)
- [Serverless Developer Guide](https://docs.aws.amazon.com/serverless/latest/devguide/welcome.html)
- [Amazon API Gateway](https://aws.amazon.com/api-gateway/)
- [Amazon API gateway FAQs](https://aws.amazon.com/api-gateway/faqs/)
- [Tutorial: Get started with Amazon EC2](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EC2_GetStarted.html)
- [What is Amazon EC2?](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/concepts.html)
- [Amazon EC2 FAQs](https://aws.amazon.com/ec2/faqs/)
- [Amazon EKS User Guide](https://docs.aws.amazon.com/eks/latest/userguide/what-is-eks.html)
- [Containers on AWS](https://aws.amazon.com/containers/services/)
- [Amazon ECS on AWS Fargate](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/AWS_Fargate.html)
- [Amazon ECS Workshop](https://ecsworkshop.com/)
- [YouTube channel - Containers from the Couch - Live streams and videos featuring AWS Container Services and demos](https://www.youtube.com/containersfromthecouch)
- [AWS Cloud Databases](https://aws.amazon.com/products/databases/)
- [AWS Cloud Databases](https://aws.amazon.com/products/databases/)
- [Using Aurora Serverless v2](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless-v2.html)
- [Getting started with Amazon Aurora](https://aws.amazon.com/rds/aurora/getting-started/)
- [Using Amazon RDS Proxy](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/rds-proxy.html)
- [What is Amazon DynamoDB?](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Introduction.html)
- [Amazon DynamoDB FAQs](https://aws.amazon.com/dynamodb/faqs/)
- [Example of modeling relational data in DynamoDB](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-modeling-nosql-B.html)
- [Hands-on labs for DynamoDB](https://catalog.workshops.aws/dynamodb-labs/en-US/hands-on-labs)
- [Units for Read/Write capacity RCU and WCU](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html)
- [What is an Event-Driven Architecture?](https://aws.amazon.com/event-driven-architecture/)
- [Amazon EventBridge](https://aws.amazon.com/eventbridge/)
- [Amazon Simple Notification Service (SNS)](https://aws.amazon.com/sns/)
- [AWS SQS vs SNS vs Eventbridge – When to Use What?](https://www.beabetterdev.com/2021/09/10/aws-sqs-vs-sns-vs-eventbridge/)
- [AWS — Difference between Amazon EventBridge and Amazon SNS](https://medium.com/awesome-cloud/aws-difference-between-amazon-eventbridge-and-amazon-sns-comparison-aws-eventbridge-vs-aws-sns-46708bf5313)
- [What is Amazon EventBridge?](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-what-is.html)
- [Amazon EventBridge FAQs](https://aws.amazon.com/eventbridge/faqs/)
- [Amazon EventBridge events](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-events.html)
- [Amazon EventBridge rules](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-rules.html)
- [Amazon EventBridge event patterns](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-event-patterns.html)
- [Amazon EventBridge event buses](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-event-bus.html)
- [Payload-based message filtering support in SNS](https://aws.amazon.com/blogs/compute/introducing-payload-based-message-filtering-for-amazon-sns/)
- [What is Amazon SNS?](https://docs.aws.amazon.com/sns/latest/dg/welcome.html)
- [Amazon SNS FAQs](https://aws.amazon.com/sns/faqs/)
- [Getting started with Amazon SNS](https://docs.aws.amazon.com/sns/latest/dg/sns-getting-started.html#step-create-queue)
- [Change data capture for DynamoDB Streams](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.html)
- [Tutorial: Process new items with DynamoDB Streams and Lambda](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.Lambda.Tutorial.html)
[Patterns for integrating microservices](https://docs.aws.amazon.com/prescriptive-guidance/latest/modernization-integrating-microservices/integrating-patterns.html)
- [Building storage-first serverless apps with HTTP APIs service integrations](https://aws.amazon.com/blogs/compute/building-storage-first-applications-with-http-apis-service-integrations/)
- [What is Amazon Simple Queue Service?](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/welcome.html)
- [Amazon SQS FAQs](https://aws.amazon.com/sqs/faqs/)
- [Using AWS Lambda with Amazon SQS](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html)
- [AWS Lambda Power Tuning](https://github.com/alexcasalboni/aws-lambda-power-tuning)
- [AWS Lambda Powertools (For TypeScript)](https://docs.powertools.aws.dev/lambda/typescript/latest/)
- [Best practices for working with AWS Lambda](https://docs.aws.amazon.com/lambda/latest/dg/best-practices.html)
- [Building well-architected serverless applications: Optimizing application costs](https://aws.amazon.com/blogs/compute/building-well-architected-serverless-applications-optimizing-application-costs/)
- [Serverless Applications Lens - AWS Well-Architected Framework](https://docs.aws.amazon.com/wellarchitected/latest/serverless-applications-lens/welcome.html)
- [Exercise 1. Architecting Solutions: Building a Proof of Concept for a Serverless Solution](https://aws-tc-largeobjects.s3.us-west-2.amazonaws.com/DEV-AWS-MO-Architecting/exercise-1-serverless.html)
